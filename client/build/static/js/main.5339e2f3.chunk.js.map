{"version":3,"sources":["App.tsx","features/counter/counterAPI.ts","features/counter/counterSlice.ts","redux/store.ts","index.tsx"],"names":["App","className","action","htmlFor","id","name","type","fetchCount","amount","Promise","resolve","setTimeout","data","incrementAsync","createAsyncThunk","a","response","counterSlice","createSlice","initialState","value","status","reducers","increment","state","decrement","incrementByAmount","payload","extraReducers","builder","addCase","pending","fulfilled","actions","store","configureStore","reducer","counter","counterReducer","render","document","getElementById"],"mappings":"uLAGaA,EAAgB,WAC3B,OACE,sBAAKC,UAAU,iBAAf,UACE,0CACA,uBAAMC,OAAO,GAAGD,UAAU,mBAA1B,UACE,sBAAKA,UAAU,kBAAf,UACE,uBAAOE,QAAQ,OAAOF,UAAU,OAAhC,kBACA,uBAAOG,GAAG,OAAOC,KAAK,OAAOC,KAAK,OAAOL,UAAU,oBAErD,sBAAKA,UAAU,kBAAf,UACE,uBAAOE,QAAQ,QAAQF,UAAU,OAAjC,mBACA,uBAAOG,GAAG,QAAQC,KAAK,QAAQC,KAAK,OAAOL,UAAU,oBAEvD,wBAAQK,KAAK,SAASL,UAAU,kBAAhC,uBAGF,qBAAKA,UAAU,YAAf,SACE,sBAAKA,UAAU,YAAf,UACE,oBAAIA,UAAU,aAAd,kBACA,mBAAGA,UAAU,YAAb,mBACA,wBAAQA,UAAU,kBAAlB,sBACA,wBAAQA,UAAU,iBAAlB,6B,8BCvBH,SAASM,IAAwB,IAAbC,EAAY,uDAAH,EAClC,OAAO,IAAIC,SAA0B,SAACC,GAAD,OACnCC,YAAW,kBAAMD,EAAQ,CAAEE,KAAMJ,MAAW,QCMhD,IAUaK,EAAiBC,YAC5B,qBAD4C,uCAE5C,WAAON,GAAP,eAAAO,EAAA,sEACyBR,EAAWC,GADpC,cACQQ,EADR,yBAGSA,EAASJ,MAHlB,2CAF4C,uDASjCK,EAAeC,YAAY,CACtCb,KAAM,UACNc,aArBiC,CACjCC,MAAO,EACPC,OAAQ,QAqBRC,SAAU,CACRC,UAAW,SAACC,GAKVA,EAAMJ,OAAS,GAEjBK,UAAW,SAACD,GACVA,EAAMJ,OAAS,GAGjBM,kBAAmB,SAACF,EAAOtB,GACzBsB,EAAMJ,OAASlB,EAAOyB,UAK1BC,cAAe,SAACC,GACdA,EACGC,QAAQjB,EAAekB,SAAS,SAACP,GAChCA,EAAMH,OAAS,aAEhBS,QAAQjB,EAAemB,WAAW,SAACR,EAAOtB,GACzCsB,EAAMH,OAAS,OACfG,EAAMJ,OAASlB,EAAOyB,cAKvB,EAAoDV,EAAagB,QAmBzDhB,GAnBR,EAAQM,UAAR,EAAmBE,UAAnB,EAA8BC,kBAmBtBT,EAAf,SC9EaiB,EAAQC,YAAe,CAClCC,QAAS,CACPC,QAASC,K,OCEbC,iBACE,cAAC,IAAD,CAAUL,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFM,SAASC,eAAe,W","file":"static/js/main.5339e2f3.chunk.js","sourcesContent":["import React from 'react'\nimport './App.css'\n\nexport const App: React.FC = () => {\n  return (\n    <div className=\"container pt-3\">\n      <h1>REST API</h1>\n      <form action=\"\" className=\"form-inline mb-3\">\n        <div className=\"form-group mr-5\">\n          <label htmlFor=\"name\" className=\"mr-3\">Name</label>\n          <input id=\"name\" name=\"name\" type=\"text\" className=\"form-control\" />\n        </div>\n        <div className=\"form-group mr-5\">\n          <label htmlFor=\"value\" className=\"mr-3\">Value</label>\n          <input id=\"value\" name=\"value\" type=\"text\" className=\"form-control\" />\n        </div>\n        <button type=\"submit\" className=\"btn btn-primary\">Create</button>\n      </form>\n\n      <div className=\"card mb-3\">\n        <div className=\"card-body\">\n          <h5 className=\"card-title\">Name</h5>\n          <p className=\"card-text\">Value</p>\n          <button className=\"btn btn-primary\">Canceled</button>\n          <button className=\"btn btn-danger\">Delete</button>\n        </div>\n      </div>\n    </div>\n  )\n}","// A mock function to mimic making an async request for data\nexport function fetchCount(amount = 1) {\n  return new Promise<{ data: number }>((resolve) =>\n    setTimeout(() => resolve({ data: amount }), 500)\n  );\n}\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { RootState, AppThunk } from '../../redux/store'\nimport { fetchCount } from './counterAPI'\n\nexport interface CounterState {\n  value: number;\n  status: 'idle' | 'loading' | 'failed';\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  status: 'idle',\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount: number) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectCount = (state: RootState) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport const incrementIfOdd = (amount: number): AppThunk => (\n  dispatch,\n  getState\n) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};\n\nexport default counterSlice.reducer;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","import React from 'react'\nimport { render } from 'react-dom'\nimport './index.css'\nimport { App } from './App'\nimport { store } from './redux/store'\nimport { Provider } from 'react-redux'\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)"],"sourceRoot":""}